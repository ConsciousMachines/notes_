// ----------------------------------------------------------------------------
//                    inference rules 1: lambda calculus
// ----------------------------------------------------------------------------

// these are the first 3 inference rules that correspond lambda calculus
// together with the logical rules for implication.

//  Gam, x:T |- t <= W
// --------------------- (-> intro)
//  Gam |- \x.t <= T->W
// to check that a lambda term \x.t has type T->W, we need to augment the
// context Gam with x:T and check that t has type W in this new context.
// for example, to show that \x.x has type A->A, we add x:A to the context,
// and check that the body x has type A in this context. to check variable
// x (from body) we then look in the context to find the x:A (from input).
// so the arrow allows us to fill the context with a variable name that we
// create like a,b,c.. and a type which is the arrow's domain type.

//  Gam |- f => T->W  Gam |- a <= T
// ---------------------------------- (-> elim)
//         Gam |- f a => W
// to synthesize a type for function application (f a) we must synthesize
// an unknown type T. thus we synthesize a type T->W for f, and then check
// that the input a matches that input type.
// to synthesize an arrow type for f would require that we have the proper
// assumptions in our context. so all we are doing is checking our
// assumptions rather than magically invent a type to work, since the
// recursive call to synth-type will look for f in the context.

//
// -------------------- (Var)
//  Gam, x:X |- x => X
// to synthesize a type for a variable we can find it in the context.
// this means we hopefully have the right variable added to the context
// through the "assumptions" generated by arrow (if a:A then b:B)

// ----------------------------------------------------------------------------
//                        inference rules 2: AND
// ----------------------------------------------------------------------------

// we now add inference rules that correspond to logical AND, and add
// structs to lambda calculus which act as boxes around 1 or 2 values.

//  Gam |- t <= T  Gam |- w <= W
// -------------------------------- (and-intro)
//  Gam |- and-intro(t,w) <= T & W
// to check that a struct consisting of values t and w has type T & W,
// we check that individually t has type T and w has type W.

//     Gam |- v => T & W
// -------------------------- (and-elim0)
//  Gam |- and-elim0(v) => T
// to synthesize a type for a "box" and-elim0 (which contains a term inside
// that we put in there, so we'd only put an and-term inside it) we have to
// synthesize the type of the original term (once again, since we wrote this,
// we'd only put an and-term with an and-type inside) and then extract the
// left type out.

//     Gam |- v => T & W
// -------------------------- (and-elim1)
//  Gam |- and-elim1(v) => W
// symmetric to and-elim0.

// ----------------------------------------------------------------------------
//                          inference rules 3: OR
// ----------------------------------------------------------------------------

//         Gam |- t <= T
// ------------------------------ (or-intro0)
//  Gam |- or-intro0(t) <= T | W
// to check that a "box" or-intro0 has type T | W, we throw out its right
// type and check that the element inside has the left type.
// when constructing such a term we take a term of known type T and then
// in effect add a wildcard type to the right, since it will be ignored
// in the type check process.
// so to prove that a term has type A | BOB_SAGET we simply need to have
// a term of type A in the context, and apply or-intro0 to it. when the
// type checker checks this term, BOB_SAGET is ignored and we only confirm
// that the boxed term has type A.

//         Gam |- w <= W
// ------------------------------ (or-intro1)
//  Gam |- or-intro1(w) <= T | W
// symmetric to or-intro0.

//  Gam |- d => T | W  Gam |- f <= T->V  Gam |- g <= W->V
// ------------------------------------------------------- (or-elim)
//                Gam |- v-elim(d,f,g) <= V
// to check that a box has type V, we first synthesize the type of d.
// we want the type of d to be an OR type so we can then create 2 functions
// from the left and right parts of the OR, and outputting type V.
// knowing these desired function types T->V and W->V, we check that f,g
// actually have those types.
// when we create an or-elim object, we have an output type in mind (V) and
// we plan to get rid of both of the possible input types (T | W). this is
// done by supplying two lambdas that will be checked against those Arrow
// types. this is interesting because we never had anything of type T or W
// in the context, but once the lambdas start being checked, their inputs
// are added to the context as types T and W respectively, per subtree.

// ----------------------------------------------------------------------------
//                                 notes
// ----------------------------------------------------------------------------

// when we are proving a formula, we apply inference rules in 2 directions:

// 1. we can apply inference rules to things in the context, and
// build a proof tree downwards. we apply intro or elim rules
// by putting variables from context into the rules' premises to get a result.

// 2. we can work upwards by decomposing the root node into a variable
// for the context, and a new sub-goal (A->B). this applies rules backwards
// because we pattern-match the formula into (A->B) to generate the premise
// A for the context, and B for the new sub-goal. Note that only the (-> intro)
// rule does this so far, and it's more like (arrow intro backwards) so
// we can think of it as "undoing arrow introduction".

// no matter if we work upwards or downwards, we are constructing a proof tree.
// the node of this tree is passed to the type checker which then works
// starting at the goal and working back towards the premises.

// we implicitly implemented TURN because all the default cases in
// type-check are passed to type-synth.

// ----------------------------------------------------------------------------
//                                pair
// ----------------------------------------------------------------------------

import java.util.HashMap;

class Pair<X, Y> {
    public final X x;
    public final Y y;

    public Pair(X x, Y y) {
        this.x = x;
        this.y = y;
    }
}

// ----------------------------------------------------------------------------
//                      parser for simple S-expressions
// ----------------------------------------------------------------------------

class Parser {
    // invariant: 'idx' always points to start of next lexeme, so when using
    // consume_char or consume_symbol, they eat up whitespace after.
    public int idx = 0;
    public String s = "";

    public char curr_char() {
        return s.charAt(idx);
    }

    public boolean char_is_whitespace(char c) {
        if ((c == ' ') || (c == '\n') || (c == '\t')) return true;
        return false;
    }

    public boolean char_is_reserved(char c) {
        if ((c == '(') || (c == ')')) return true;
        return false;
    }

    public void __consume_whitespace() {
        if (idx < s.length()) {
            while (char_is_whitespace(curr_char())) idx++;
        }
    }

    public String consume_symbol() {
        int start = idx;
        while (true) {
            char c = curr_char();
            if (char_is_reserved(c) || char_is_whitespace(c)) break;
            idx++;
        }
        String ret = s.substring(start, idx);
        __consume_whitespace();
        return ret;
    }

    public void consume_char(char c) {
        if (curr_char() == c) idx++;
        else throw new RuntimeException("expected '" + c + "'");
        __consume_whitespace();
    }

    public Type parse_type() {
        Type t = new Type();
        if (curr_char() == '(') {
            consume_char('(');
            Type t1 = parse_type();
            String type_op = consume_symbol();
            Type t2 = parse_type();
            consume_char(')');
            t.fst = t1;
            t.snd = t2;
            if (type_op.equals("->")) t.k = TypeKind.Arrow;
            else if (type_op.equals("&")) t.k = TypeKind.And;
            else if (type_op.equals("|")) t.k = TypeKind.Or;
            else throw new RuntimeException("unknown operand in type-formula");
        }
        else {
            String symbol = consume_symbol();
            t.k = TypeKind.Var;
            t.symbol = symbol;
        }
        return t;
    }
}

// ----------------------------------------------------------------------------
//                      context is a linked list
// ----------------------------------------------------------------------------

class ContextNode {
    String symbol = null;
    Type type = null;
    ContextNode prev = null;

    public ContextNode() {
    }

    public ContextNode(String symbol, Type type) {
        this.symbol = symbol;
        this.type = type;
    }

    Type assoc(String symbol) {
        if (this.symbol.equals(symbol)) return this.type;
        if (this.prev == null) return null;
        return this.prev.assoc(symbol);
    }

    public String toString() {
        String ret = symbol + " : " + type + "\n";
        if (this.prev != null) ret += this.prev.toString();
        return ret;
    }
}

// ----------------------------------------------------------------------------
//                        nodes for building proof trees
// ----------------------------------------------------------------------------

enum TermType {
    Var, Lam, App, Ann, Hole, And_intro, And_elim0, And_elim1, Or_intro0, Or_intro1, Or_elim
}

class Term {
    TermType t;
    Term fst, snd, thr; // for compound types
    Type ann_type;      // for annotation
    String symbol;      // for var
    Integer hole_num;   // for hole, nullable

    private Term(TermType t, Term fst, Term snd, Type ann_type, String symbol, Integer hole_num,
                 Term thr) {
        this.t = t;
        this.fst = fst;
        this.snd = snd;
        this.ann_type = ann_type;
        this.symbol = symbol;
        this.hole_num = hole_num;
        this.thr = thr;
    }

    public String toString() {
        switch (this.t) {
            case Or_elim:
                return "(or-elim " + fst + " " + snd + " " + thr + ")";
            case Or_intro1:
                return "(or-intro1 " + fst + ")";
            case Or_intro0:
                return "(or-intro0 " + fst + ")";
            case And_elim1:
                return "(and-elim1 " + fst + ")";
            case And_elim0:
                return "(and-elim0 " + fst + ")";
            case And_intro:
                return "(and-intro " + fst + " " + snd + ")";
            case Var:
                return this.symbol;
            case Lam:
                return "(\\" + fst + "." + snd + ")";
            case App:
                return "(" + fst + " " + snd + ")";
            case Ann:
                return "(" + fst + " : " + ann_type + ")";
            case Hole:
                return "?" + hole_num;
            default:
                throw new RuntimeException("unreachable");
        }
    }

    // static methods to easily create terms (for interactive proof)

    static Term var(String s) {
        return new Term(TermType.Var, null, null, null, s, 0, null);
    }

    static Term lam(String s, Term body) {
        return new Term(TermType.Lam, Term.var(s), body, null, null, 0, null);
    }

    static Term app(Term rator, Term rand) {
        return new Term(TermType.App, rator, rand, null, null, 0, null);
    }

    static Term ann(Term expr, Type ann_type) {
        return new Term(TermType.Ann, expr, null, ann_type, null, 0, null);
    }

    static Term hole(int hole_num) {
        return new Term(TermType.Hole, null, null, null, null, hole_num, null);
    }

    static Term hole() {
        return new Term(TermType.Hole, null, null, null, null, null, null);
    }

    static Term and_intro(Term t1, Term t2) {
        return new Term(TermType.And_intro, t1, t2, null, null, null, null);
    }

    static Term and_elim0(Term t) {
        return new Term(TermType.And_elim0, t, null, null, null, null, null);
    }

    static Term and_elim1(Term t) {
        return new Term(TermType.And_elim1, t, null, null, null, null, null);
    }

    static Term or_intro0(Term t) {
        return new Term(TermType.Or_intro0, t, null, null, null, null, null);
    }

    static Term or_intro1(Term t) {
        return new Term(TermType.Or_intro1, t, null, null, null, null, null);
    }

    static Term or_elim(Term t1, Term t2, Term t3) {
        return new Term(TermType.Or_elim, t1, t2, null, null, null, t3);
    }
}

enum TypeKind {Var, Arrow, And, Or}

class Type {
    TypeKind k;
    Type fst, snd; // for compound type
    String symbol; // for type variable

    public Type() {
    }

    public Type(TypeKind k, Type fst, Type snd, String symbol) {
        this.k = k;
        this.fst = fst;
        this.snd = snd;
        this.symbol = symbol;
    }

    public String toString() {
        switch (k) {
            case Arrow:
                return "(" + fst + " -> " + snd + ")";
            case And:
                return "(" + fst + " & " + snd + ")";
            case Or:
                return "(" + fst + " | " + snd + ")";
            case Var:
                return symbol;
            default:
                throw new RuntimeException("unreachable");
        }
    }

    public boolean equals(Type t2) {
        if (this.k != t2.k) return false;
        switch (this.k) {
            case Var:
                return this.symbol.equals(t2.symbol);
            case Arrow:
                return this.fst.equals(t2.fst) && this.snd.equals(t2.snd);
            default:
                throw new RuntimeException("unreachable");
        }
    }
}

// ----------------------------------------------------------------------------
//                           the main proof assistant
// ----------------------------------------------------------------------------

class proust_2 {

    void type_check(ContextNode ctx, Term expr, Type type) {
        switch (expr.t) {
            case Or_elim:
                Term d = expr.fst;
                Term f = expr.snd;
                Term g = expr.thr;
                Type t00 = type_synth(ctx, d);
                if (t00.k != TypeKind.Or)
                    throw new RuntimeException("Or-elim failed to synth OR type");
                Type t1 = new Type(TypeKind.Arrow, t00.fst, type, null);
                Type t2 = new Type(TypeKind.Arrow, t00.snd, type, null);
                type_check(ctx, f, t1);
                type_check(ctx, g, t2);
                return;
            case Or_intro1:
                if (type.k != TypeKind.Or)
                    throw new RuntimeException("Or-intro1 didn't get OR type");
                type_check(ctx, expr.fst, type.snd);
                return;
            case Or_intro0:
                if (type.k != TypeKind.Or)
                    throw new RuntimeException("Or-intro0 didn't get OR type");
                type_check(ctx, expr.fst, type.fst);
                return;
            case And_intro:
                type_check(ctx, expr.fst, type.fst);
                type_check(ctx, expr.snd, type.snd);
                return;
            case Lam: // backwards of arrow introduction rule
                if (type.k != TypeKind.Arrow)
                    throw new RuntimeException("Lambda not matched with arrow type");
                ContextNode ctx2 = new ContextNode(expr.fst.symbol, type.fst);
                ctx2.prev = ctx; // augment context with input
                type_check(ctx2, expr.snd, type.snd); // check that body has output type
                return;
            case Hole:
                if (refining) { // enter hole in goal table
                    goal_table.put(expr.hole_num, new Pair(type, ctx));
                }
                return;
            default: // send to type-synth, in effect implementing TURN
                Type t0 = type_synth(ctx, expr);
                if (!type.equals(t0))
                    throw new RuntimeException("failed type synth:" + type + " vs " + t0);
                return;
        }
    }

    Type type_synth(ContextNode ctx, Term expr) {
        Type t;
        switch (expr.t) // Var, Lam, App, Ann, Hole
        {
            case And_elim1:
                t = type_synth(ctx, expr.fst);
                if (t.k == TypeKind.And) return t.snd;
                else throw new RuntimeException("And-elim1 did not synthesize & type");
            case And_elim0:
                t = type_synth(ctx, expr.fst);
                if (t.k == TypeKind.And) return t.fst;
                else throw new RuntimeException("And-elim0 did not synthesize & type");
            case Ann:
                type_check(ctx, expr.fst, expr.ann_type);
                return expr.ann_type;
            case App:
                t = type_synth(ctx, expr.fst); // synthesize function's type
                if (t.k == TypeKind.Arrow) {
                    type_check(ctx, expr.snd, t.fst); // type check the input
                    return t.snd;
                }
                else {
                    throw new RuntimeException("function type did not synthesize to Arrow");
                }
            case Var:
                t = ctx.assoc(expr.symbol); // type from context
                if (t == null) throw new RuntimeException("term not in context: " + expr.symbol);
                return t;
            default:
                throw new RuntimeException("failed to synthesize type");
        }
    }

    boolean refining = false;
    int hole_ctr;
    Parser parser;
    Term current_expr;
    HashMap<Integer, Pair<Type, ContextNode>> goal_table;

    int use_hole_ctr() {
        return hole_ctr++;
    }

    void set_task(String s) {
        parser = new Parser();
        parser.s = s;
        Type t = parser.parse_type();
        goal_table = new HashMap<>();
        hole_ctr = 1;
        current_expr = Term.ann(Term.hole(0), t);
        goal_table.put(0, new Pair(t, null));
        System.out.println("\nTask is now\n" + current_expr);
    }

    void print_goal() {
        for (int i : goal_table.keySet()) {
            System.out.println("Goal " + i + " has type: " + goal_table.get(i).x);
            System.out.println("in context\n" + goal_table.get(i).y);
        }
    }

    Term number_new_holes(Term e) {
        switch (e.t) {
            case Or_elim:
                return Term.or_elim(number_new_holes(e.fst), number_new_holes(e.snd),
                                    number_new_holes(e.thr));
            case Or_intro1:
                return Term.or_intro1(number_new_holes(e.fst));
            case Or_intro0:
                return Term.or_intro0(number_new_holes(e.fst));
            case And_elim1:
                return Term.and_elim1(number_new_holes(e.fst));
            case And_elim0:
                return Term.and_elim0(number_new_holes(e.fst));
            case And_intro:
                return Term.and_intro(number_new_holes(e.fst), number_new_holes(e.snd));
            case Lam:
                return Term.lam(e.fst.symbol, number_new_holes(e.snd));
            case App:
                return Term.app(number_new_holes(e.fst), number_new_holes(e.snd));
            case Var:
                return e;
            case Ann:
                return Term.ann(number_new_holes(e.fst), e.ann_type);
            case Hole:
                if (e.hole_num != null) return Term.hole(e.hole_num);
                else return Term.hole(use_hole_ctr());
            default:
                throw new RuntimeException("unreachable in number_new_holes");
        }
    }

    Term replace_goal_with(int n, Term repl, Term e) {
        switch (e.t) {
            case Lam:
                return Term.lam(e.fst.symbol, replace_goal_with(n, repl, e.snd));
            case App:
                return Term.app(replace_goal_with(n, repl, e.fst),
                                replace_goal_with(n, repl, e.snd));
            case Var:
                return e;
            case Ann:
                return Term.ann(replace_goal_with(n, repl, e.fst), e.ann_type);
            case Hole:
                if (e.hole_num == n) return repl;
                else return Term.hole(e.hole_num);
            default:
                throw new RuntimeException("unreachable");
        }
    }

    void refine(int n, Term e) {
        Pair<Type, ContextNode> pair = goal_table.get(n);
        Type t = pair.x;
        ContextNode ctx = pair.y;
        type_check(ctx, e, t); // first time, just check
        Term en = number_new_holes(e);
        refining = true;
        type_check(ctx, en, t); // second time, add goals to table
        refining = false;
        goal_table.remove(n);
        current_expr = replace_goal_with(n, en, current_expr);
        System.out.println("\nTask with " + goal_table.size() + " goals is now\n" + current_expr);
        print_goal();
    }

    void test() {
        /*
        set_task("((A | A) -> A)");
        refine(0, Term.lam("d", Term.hole()));
        Term l = Term.lam("a", Term.var("a"));
        refine(1, Term.or_elim(Term.var("d"), l, l));

        set_task("((A | B) -> (B | A))");
        refine(0, Term.lam("d", Term.hole()));
        Term soy2 = Term.lam("a", Term.or_intro1(Term.var("a")));
        Term soy3 = Term.lam("b", Term.or_intro0(Term.var("b")));
        refine(1, Term.or_elim(Term.var("d"), soy2, soy3));

         */


        // TODO: or excercises
        set_task("((A -> B) -> ((A | C) -> (B | C)))");
        refine(0, Term.lam("a", Term.hole()));
        refine(1, Term.lam("b", Term.hole()));
        Term borc = Term.or_elim()
    }

    public static void main(String[] args) {
        proust_2 proust = new proust_2();
        proust.test();
    }
}


