plot(g)
# diameter of Zachary graph
print(diameter(g))
# degree distribution
plot(degree_distribution(g), type='l')
# Clustering coefficients of all vertices
vertex_clustering_coeff <- transitivity(g, type = "local")
# Clustering coefficient for the graph
graph_clustering_coeff <- transitivity(g, type = "global")
cat("Vertex clustering coefficients:", vertex_clustering_coeff, "\n")
cat("Graph clustering coefficient:", graph_clustering_coeff, "\n")
# Closeness centrality
closeness_centrality <- closeness(g)
# Betweenness centrality
betweenness_centrality <- betweenness(g)
cat("Closeness centrality:", closeness_centrality, "\n")
cat("Betweenness centrality:", betweenness_centrality, "\n")
# b)
# find the degree distribution
plot(degree_distribution(g), type='l')
zachary_dir = '/home/chad/Desktop/skool/840/zachary.txt'
data = read.table(zachary_dir)
data = data[,c(1,2)] # remove weights column
g = graph_from_edgelist(data, directed=FALSE)
g = graph_from_edgelist(matrix(data), directed=FALSE)
matrix(data)
data
matrix(data, ncol=2, nrow=78)
as.matrix(data)
g = graph_from_edgelist(as.matrix(data), directed=FALSE)
zachary_dir = '/home/chad/Desktop/skool/840/zachary.txt'
data = read.table(zachary_dir)
data = data[,c(1,2)] # remove weights column
g = graph_from_edgelist(as.matrix(data), directed=FALSE)
g = graph_from_edgelist(as.matrix(data), directed=FALSE)
# a)
# draw the graph, find diameter of graph
plot(g)
grapg = graph_from_edgelist(as.matrix(data), directed=FALSE)
g = graph_from_edgelist(as.matrix(data), directed=FALSE)
# a)
# draw the graph, find diameter of graph
plot(g)
print(diameter(g))
# b)
# find the degree distribution
plot(degree_distribution(g), type='l')
# d)
# find closeness and betweenness centralities of the vertices
print(closeness(g))
print(betweenness(g))
# d)
# find closeness and betweenness centralities of the vertices
plot(closeness(g))
rint
rint
print(betweenness(g))
# a)
# draw the graph, find diameter of graph
rglplot(g)
# a)
# draw the graph, find diameter of graph
rglplot(g)
# a)
# draw the graph, find diameter of graph
rglplot(g)
# a)
# draw the graph, find diameter of graph
rglplot(g)
# a)
# draw the graph, find diameter of graph
plot.igraph(g)
diameter(g, directed = FALSE)
diameter(g, directed = FALSE)
# b)
# find the degree distribution
#
degree_distribution(g, cumulative=FALSE)
plot(degree_distribution(g, cumulative=FALSE)
, type='l')
plot(degree_distribution(g, cumulative=FALSE), type='l')
# d)
# find closeness and betweenness centralities of the vertices
# https://r.igraph.org/reference/closeness.html?q=closeness#null
closeness(g)
# https://r.igraph.org/reference/betweenness.html?q=betweenness#null
betweenness(g)
# d)
# find closeness and betweenness centralities of the vertices
# https://r.igraph.org/reference/closeness.html?q=closeness#null
plot(closeness(g), type='l')
# https://r.igraph.org/reference/betweenness.html?q=betweenness#null
plot(betweenness(g), type='l')
# https://r.igraph.org/reference/betweenness.html?q=betweenness#null
plot(betweenness(g), type='l', main='betweenness')
# d)
# find closeness and betweenness centralities of the vertices
# https://r.igraph.org/reference/closeness.html?q=closeness#null
plot(closeness(g), type='l', main='closeness')
# https://r.igraph.org/reference/betweenness.html?q=betweenness#null
plot(betweenness(g), type='l', main='betweenness')
(degree_distribution(g, cumulative=FALSE), type='l', main='degree distribution')
# b)
# find the degree distribution
# https://r.igraph.org/reference/degree.html?q=degree%20distrib#null
plot(degree_distribution(g, cumulative=FALSE), type='l', main='degree distribution')
# a)
# draw the graph, find diameter of graph
# https://r.igraph.org/reference/plot.common.html?q=draw#null
plot.igraph(g)
# https://r.igraph.org/reference/diameter.html?q=diameter#null
diameter(g, directed = FALSE)
# b)
# find the degree distribution
# https://r.igraph.org/reference/degree.html?q=degree%20distrib#null
plot(degree_distribution(g, cumulative=FALSE), type='l', main='degree distribution')
# Clustering coefficient for the graph
transitivity(g, type = "global")
# Clustering coefficients of all vertices
transitivity(g, type = "local")
# Clustering coefficients of all vertices
plot(transitivity(g, type = "local"), type='l')
# a)
# draw the graph, find diameter of graph
# https://r.igraph.org/reference/plot.common.html?q=draw#null
plot.igraph(g)
# Clustering coefficients of all vertices
plot(transitivity(g, type = "local"), type='l')
# a)
# draw the graph, find diameter of graph
# https://r.igraph.org/reference/plot.common.html?q=draw#null
plot.igraph(g)
# a)
# draw the graph, find diameter of graph
# https://r.igraph.org/reference/plot.common.html?q=draw#null
plot.igraph(g)
# a)
# draw the graph, find diameter of graph
# https://r.igraph.org/reference/plot.common.html?q=draw#null
plot.igraph(g)
# a)
# draw the graph, find diameter of graph
# https://r.igraph.org/reference/plot.common.html?q=draw#null
plot.igraph(g)
# Clustering coefficients of all vertices
plot(transitivity(g, type = "local"), type='l')
# c)
# find clustering coefficients of all vertices and therefore for the graph
# number 12 is NAN because it only has one neighbor
plot(transitivity(g, type = "local"), type='l')
# c)
# find clustering coefficients of all vertices and therefore for the graph
# number 12 is NAN because it only has one neighbor
# clustering coefficient for all vertices
plot(transitivity(g, type = "local"), type='l')
# Clustering coefficient for the graph
transitivity(g, type = "global")
# a)
# draw the graph, find diameter of graph
# https://r.igraph.org/reference/plot.common.html?q=draw#null
plot.igraph(g)
# Clustering coefficient for the graph
transitivity(g, type = "global")
# c)
# find clustering coefficients of all vertices and for the graph
# number 12 is NAN because it only has one neighbor
# clustering coefficient for all vertices
plot(transitivity(g, type="local"), type='l')
# clustering coefficient for entire graph
transitivity(g, type = "global")
zachary_dir = '/home/chad/Desktop/skool/840/zachary.txt'
library(igraph)
zachary_dir = '/home/chad/Desktop/skool/840/zachary.txt'
data = read.table(zachary_dir)
data = data[,c(1,2)] # remove weights column
g = graph_from_edgelist(as.matrix(data), directed=FALSE)
# a)
# draw the graph, find diameter of graph
# https://r.igraph.org/reference/plot.common.html?q=draw#null
plot.igraph(g)
# https://r.igraph.org/reference/diameter.html?q=diameter#null
diameter(g, directed = FALSE)
# b)
# find the degree distribution
# https://r.igraph.org/reference/degree.html?q=degree%20distrib#null
plot(degree_distribution(g, cumulative=FALSE), type='l', main='degree distribution')
# b)
# find the degree distribution
# https://r.igraph.org/reference/degree.html?q=degree%20distrib#null
plot(degree_distribution(g, cumulative=FALSE), type='l', main='degree distribution')
# c)
# find clustering coefficients of all vertices and for the graph
# https://r.igraph.org/reference/transitivity.html?q=clustering%20coeff#null
# number 12 is NAN because it only has one neighbor
# clustering coefficient for all vertices
plot(transitivity(g, type="local"), type='l', main='clustering coefficient for all vertices')
# clustering coefficient for entire graph
transitivity(g, type = "global")
mean(transitivity(g, type="local"))
# clustering coefficient for entire graph
transitivity(g, type = "global")
# c)
# find clustering coefficients of all vertices and for the graph
# https://r.igraph.org/reference/transitivity.html?q=clustering%20coeff#null
# number 12 is NAN because it only has one neighbor
# clustering coefficient for all vertices
plot(transitivity(g, type="local"), type='l', main='clustering coefficient for all vertices')
# clustering coefficient for entire graph
transitivity(g, type = "global")
# d)
# find closeness and betweenness centralities of the vertices
# https://r.igraph.org/reference/closeness.html?q=closeness#null
plot(closeness(g), type='l', main='closeness')
# https://r.igraph.org/reference/betweenness.html?q=betweenness#null
plot(betweenness(g), type='l', main='betweenness')
hessian = matrix(nrow=3,ncol=3)
hessian
hessian = matrix(nrow=3,ncol=3) * 0
hessian
hessian = matrix(data=0,nrow=3,ncol=3)
hessian
x = c(24, 18, 21, 5, 5, 11, 11, 17, 6, 7, 20, 13, 4, 16, 19, 21, 4, 22, 8, 17)
lik = -Inf
while (TRUE)
{
# E step
pois1 =     p * dpois(x, lam1)
pois2 = (1-p) * dpois(x, lam2)
w     = pois1 / (pois1 + pois2)
# M step
p    = mean(w)
lam1 = sum(w     * x) / sum(w)
lam2 = sum((1-w) * x) / sum(1-w)
# check convergence
lik_new = sum(log(p * dpois(x, lam1) + (1-p) * dpois(x, lam2)))
if (abs(lik_new - lik) < 1e-8)
break
lik = lik_new
}
p = 0.5
lam1 = 1
lam2 = 1
x = c(24, 18, 21, 5, 5, 11, 11, 17, 6, 7, 20, 13, 4, 16, 19, 21, 4, 22, 8, 17)
lik = -Inf
while (TRUE)
{
# E step
pois1 =     p * dpois(x, lam1)
pois2 = (1-p) * dpois(x, lam2)
w     = pois1 / (pois1 + pois2)
# M step
p    = mean(w)
lam1 = sum(w     * x) / sum(w)
lam2 = sum((1-w) * x) / sum(1-w)
# check convergence
lik_new = sum(log(p * dpois(x, lam1) + (1-p) * dpois(x, lam2)))
if (abs(lik_new - lik) < 1e-8)
break
lik = lik_new
}
p
lam1
lam2
lam2 = 10
x = c(24, 18, 21, 5, 5, 11, 11, 17, 6, 7, 20, 13, 4, 16, 19, 21, 4, 22, 8, 17)
p = 0.5
lam1 = 1
lam2 = 10
x = c(24, 18, 21, 5, 5, 11, 11, 17, 6, 7, 20, 13, 4, 16, 19, 21, 4, 22, 8, 17)
lik = -Inf
while (TRUE)
{
# E step
pois1 =     p * dpois(x, lam1)
pois2 = (1-p) * dpois(x, lam2)
w     = pois1 / (pois1 + pois2)
# M step
p    = mean(w)
lam1 = sum(w     * x) / sum(w)
lam2 = sum((1-w) * x) / sum(1-w)
# check convergence
lik_new = sum(log(p * dpois(x, lam1) + (1-p) * dpois(x, lam2)))
if (abs(lik_new - lik) < 1e-8)
break
lik = lik_new
}
p
lam1
lam2
install.packages("numDeriv")
library(numDeriv)
library(numDeriv)
observed_lik = function(p, lam1, lam2, x, Z_probs) {
pois1 = dpois(x, lam1)
pois2 = dpois(x, lam2)
observed_lik = sum(log(p*pos1 + (1-p)*pois2))
return(lik)
}
observed_lik = function(p, lam1, lam2, x, Z_probs) {
pois1 = dpois(x, lam1)
pois2 = dpois(x, lam2)
lik = sum(log(p*pos1 + (1-p)*pois2))
return(lik)
}
library(numDeriv)
observed_lik = function(p, lam1, lam2, x, Z_probs) {
pois1 = dpois(x, lam1)
pois2 = dpois(x, lam2)
lik = sum(log(p*pos1 + (1-p)*pois2))
return(lik)
}
p = 0.5
lam1 = 1
lam2 = 10
x = c(24, 18, 21, 5, 5, 11, 11, 17, 6, 7, 20, 13, 4, 16, 19, 21, 4, 22, 8, 17)
lik = -Inf
while (TRUE)
{
# E step
pois1 =     p * dpois(x, lam1)
pois2 = (1-p) * dpois(x, lam2)
w     = pois1 / (pois1 + pois2)
# M step
p    = mean(w)
lam1 = sum(w     * x) / sum(w)
lam2 = sum((1-w) * x) / sum(1-w)
# check convergence
lik_new = sum(log(p * dpois(x, lam1) + (1-p) * dpois(x, lam2)))
if (abs(lik_new - lik) < 1e-8)
break
lik = lik_new
}
p
lam1
lam2
H = hessian(expected_log_likelihood, p,lam1,lam2, x)
var_cov_matrix = solve(-H)
H = hessian(observed_lik, p,lam1,lam2, x)
observed_lik = function(p, lam1, lam2, x) {
pois1 = dpois(x, lam1)
pois2 = dpois(x, lam2)
lik = sum(log(p*pos1 + (1-p)*pois2))
return(lik)
}
p = 0.5
lam1 = 1
lam2 = 10
x = c(24, 18, 21, 5, 5, 11, 11, 17, 6, 7, 20, 13, 4, 16, 19, 21, 4, 22, 8, 17)
lik = -Inf
while (TRUE)
{
# E step
pois1 =     p * dpois(x, lam1)
pois2 = (1-p) * dpois(x, lam2)
w     = pois1 / (pois1 + pois2)
# M step
p    = mean(w)
lam1 = sum(w     * x) / sum(w)
lam2 = sum((1-w) * x) / sum(1-w)
# check convergence
lik_new = sum(log(p * dpois(x, lam1) + (1-p) * dpois(x, lam2)))
if (abs(lik_new - lik) < 1e-8)
break
lik = lik_new
}
p
lam1
lam2
H = hessian(observed_lik, p,lam1,lam2, x)
observed_lik = function(params)
{
p = params[1]
lam1 = params[2]
lam2 = params[3]
pois1 = dpois(x, lam1)
pois2 = dpois(x, lam2)
lik = sum(log(p*pos1 + (1-p)*pois2))
return(lik)
}
p = 0.5
lam1 = 1
lam2 = 10
x = c(24, 18, 21, 5, 5, 11, 11, 17, 6, 7, 20, 13, 4, 16, 19, 21, 4, 22, 8, 17)
lik = -Inf
while (TRUE)
{
# E step
pois1 =     p * dpois(x, lam1)
pois2 = (1-p) * dpois(x, lam2)
w     = pois1 / (pois1 + pois2)
# M step
p    = mean(w)
lam1 = sum(w     * x) / sum(w)
lam2 = sum((1-w) * x) / sum(1-w)
# check convergence
lik_new = sum(log(p * dpois(x, lam1) + (1-p) * dpois(x, lam2)))
if (abs(lik_new - lik) < 1e-8)
break
lik = lik_new
}
p
lam1
lam2
H = hessian(observed_lik, c(p,lam1,lam2)
var_cov_matrix = solve(-H)
H = hessian(observed_lik, c(p,lam1,lam2))
observed_lik = function(params)
{
p = params[1]
lam1 = params[2]
lam2 = params[3]
pois1 = dpois(x, lam1)
pois2 = dpois(x, lam2)
lik = sum(log(p*pois1 + (1-p)*pois2))
return(lik)
}
p = 0.5
lam1 = 1
lam2 = 10
x = c(24, 18, 21, 5, 5, 11, 11, 17, 6, 7, 20, 13, 4, 16, 19, 21, 4, 22, 8, 17)
lik = -Inf
while (TRUE)
{
# E step
pois1 =     p * dpois(x, lam1)
pois2 = (1-p) * dpois(x, lam2)
w     = pois1 / (pois1 + pois2)
# M step
p    = mean(w)
lam1 = sum(w     * x) / sum(w)
lam2 = sum((1-w) * x) / sum(1-w)
# check convergence
lik_new = sum(log(p * dpois(x, lam1) + (1-p) * dpois(x, lam2)))
if (abs(lik_new - lik) < 1e-8)
break
lik = lik_new
}
p
lam1
lam2
H = hessian(observed_lik, c(p,lam1,lam2))
var_cov_matrix = solve(-H)
std_errors = sqrt(diag(var_cov_matrix))
std_errors
H = hessian(observed_lik, c(p,lam1,lam2))
var_cov_matrix = solve(-H)
err = sqrt(diag(var_cov_matrix))
c(std_p=err[1], std_lam1=err[2], std_lam2=err[3])
std_errors
p = 0.5
lam1 = 1
lam2 = 10
x = c(24, 18, 21, 5, 5, 11, 11, 17, 6, 7, 20, 13, 4, 16, 19, 21, 4, 22, 8, 17)
lik = -Inf
while (TRUE)
{
# E step
pois1 =     p * dpois(x, lam1)
pois2 = (1-p) * dpois(x, lam2)
w     = pois1 / (pois1 + pois2)
# M step
p    = mean(w)
lam1 = sum(w     * x) / sum(w)
lam2 = sum((1-w) * x) / sum(1-w)
# check convergence
lik_new = sum(log(p * dpois(x, lam1) + (1-p) * dpois(x, lam2)))
if (abs(lik_new - lik) < 1e-8)
break
lik = lik_new
}
expected_log_likelihood <- function(params, data, Z_probs) {
p <- params[1]
lambda1 <- params[2]
lambda2 <- params[3]
# Compute the Poisson probabilities for each component
poisson1 <- dpois(data, lambda1)
poisson2 <- dpois(data, lambda2)
# Compute the expected log-likelihood using Z_probs
log_likelihood <- sum(Z_probs[,1] * log(p * poisson1) + Z_probs[,2] * log((1 - p) * poisson2))
return(log_likelihood)
}
# Vector of parameter estimates
params_hat <- c(p_hat, lambda1_hat, lambda2_hat)
# Vector of parameter estimates
params_hat <- c(p, lam1, lam2)
# Compute the Hessian matrix
H <- hessian(expected_log_likelihood, params_hat, data = your_data, Z_probs = Z_probs)
# Compute the Hessian matrix
H <- hessian(expected_log_likelihood, params_hat, data = x, Z_probs = Z_probs)
# Compute the Hessian matrix
H <- hessian(expected_log_likelihood, params_hat, data = x, Z_probs = w)
length(w)
length(x)
expected_log_likelihood <- function(params, data, Z_probs) {
p <- params[1]
lambda1 <- params[2]
lambda2 <- params[3]
# Compute the Poisson probabilities for each component
poisson1 <- dpois(data, lambda1)
poisson2 <- dpois(data, lambda2)
# Compute the expected log-likelihood using Z_probs
log_likelihood <- sum(Z_probs * log(p * poisson1) + (1-Z_probs) * log((1 - p) * poisson2))
return(log_likelihood)
}
# Vector of parameter estimates
params_hat <- c(p, lam1, lam2)
# Compute the Hessian matrix
H <- hessian(expected_log_likelihood, params_hat, data = x, Z_probs = w)
OIM <- -H
var_cov_matrix <- solve(OIM)
std_errors <- sqrt(diag(var_cov_matrix))
std_errors
